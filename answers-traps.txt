阅读call.asm中函数g、f和main的代码
1. 哪些寄存器保存函数的参数？例如，在main对printf的调用中，哪个寄存器保存13？
函数参数从a0到a7存储，13是第三个参数，所以是a2保存；


2. main的汇编代码中对函数f的调用在哪里？对g的调用在哪里(提示：编译器可能会将函数内联）
提示已经给出答案，汇编代码的sp没有变动，也没有存入ra，说明没有进行函数调用，f8已经被函数内联优化并且提前算出答案11了，这一行调用就是打印12、13；
				
				
3. printf函数位于哪个地址？
调用位置在 30:   00000097            auipc   ra,0x0
 34:   5e6080e7            jalr    1510(ra) # 616 <printf>

 存入pc0x30到ra，1510的16进制对应0x5e6，所以跳转地址是二者相加0x616；

4. 在main中printf的jalr之后的寄存器ra中有什么值？
0x38,寄存器存储返回PC地址执行下一条指令pc；

5. 运行以下代码：
  unsigned int i = 0x00646c72;
  printf("H%x Wo%s", 57616, &i);
程序的输出是什么？这是将字节映射到字符的ASCII码表。如果RISC-V是大端存储，为了得到相同的输出，你会把i设置成什么？是否需要将57616更改为其他值？

%x打印16进制，即e110；一个16进制数的一位是4位，存储单元可以存储2个数字;RISCV采用小端存储，所以高到低址存储的是72，6c，64；十进制114，108，100，对应ASCII r l d，所以打印结果"He110 World";(存数据的是栈结构，小端就是先存不重要的高位，所以72最后存，最早取（猜的）)；

%x代表16进制解析，这种情况下值的解析不会单独对某个字节进行，无论是大端还是小端存储，都是将其拼接再转换成16进制。（内存的存储分大小端，但是原字节序是不会变的），因此57616不应该变；

如果是大端存储，为了得到同样结果，72代表r需要最后存，最早取，大端先存低位，所以就是0x726c64；

6. 在下面的代码中，“y=”之后将打印什么(注：答案不是一个特定的值)？为什么会发生这种情况？
  printf("x=%d y=%d", 3);
x=3，y出现未定义行为，可能是栈中残存数据，或者未初始化的空间；
